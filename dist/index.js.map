{"version":3,"file":"index.js","sources":["../src/utils.js","../src/hooks/useTableState.js","../src/hooks/useTable.js","../src/hooks/useColumns.js","../src/hooks/useRows.js","../src/actions.js","../src/hooks/useExpanded.js","../src/filterTypes.js","../src/hooks/useFilters.js","../src/aggregations.js","../src/hooks/useGroupBy.js","../src/sortTypes.js","../src/hooks/useSortBy.js","../src/hooks/usePagination.js","../src/hooks/useFlexLayout.js","../src/hooks/useTokenPagination.js"],"sourcesContent":["import React from 'react'\n\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj\n  }\n  const pathObj = makePathArray(path)\n  let val\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\n  } catch (e) {\n    // continue regardless of error\n  }\n  return typeof val !== 'undefined' ? val : def\n}\n\nexport function defaultOrderByFn(arr, funcs, dirs) {\n  return [...arr].sort((rowA, rowB) => {\n    for (let i = 0; i < funcs.length; i += 1) {\n      const sortFn = funcs[i]\n      const desc = dirs[i] === false || dirs[i] === 'desc'\n      const sortInt = sortFn(rowA, rowB)\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt\n      }\n    }\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index\n  })\n}\n\nexport function getFirstDefined(...args) {\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i]\n    }\n  }\n}\n\nexport function defaultGroupByFn(rows, grouper) {\n  return rows.reduce((prev, row, i) => {\n    const resKey =\n      typeof grouper === 'function'\n        ? grouper(row.values, i)\n        : row.values[grouper]\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\n    prev[resKey].push(row)\n    return prev\n  }, {})\n}\n\nexport function setBy(obj = {}, path, value) {\n  const recurse = (obj, depth = 0) => {\n    const key = path[depth]\n    const target = typeof obj[key] !== 'object' ? {} : obj[key]\n    const subValue =\n      depth === path.length - 1 ? value : recurse(target, depth + 1)\n    return {\n      ...obj,\n      [key]: subValue,\n    }\n  }\n\n  return recurse(obj)\n}\n\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect()\n  const style = window.getComputedStyle(element)\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight),\n  }\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight),\n  }\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(\n      rect.width + margins.left + margins.right + padding.left + padding.right\n    ),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth,\n  }\n}\n\nexport function flexRender(Comp, props) {\n  if (typeof Comp === 'function') {\n    return Object.getPrototypeOf(Comp).isReactComponent ? (\n      <Comp {...props} />\n    ) : (\n      Comp(props)\n    )\n  }\n  return Comp\n}\n\nexport const mergeProps = (...groups) => {\n  let props = {}\n  groups.forEach(({ style = {}, className, ...rest } = {}) => {\n    props = {\n      ...props,\n      ...rest,\n      style: {\n        ...(props.style || {}),\n        ...style,\n      },\n      className: [props.className, className].filter(Boolean).join(' '),\n    }\n  })\n  return props\n}\n\nexport const applyHooks = (hooks, initial, ...args) =>\n  hooks.reduce((prev, next) => next(prev, ...args), initial)\n\nexport const applyPropHooks = (hooks, ...args) =>\n  hooks.reduce((prev, next) => mergeProps(prev, next(...args)), {})\n\nexport const warnUnknownProps = props => {\n  if (Object.keys(props).length) {\n    throw new Error(\n      `Unknown options passed to useReactTable:\n\n${JSON.stringify(props, null, 2)}`\n    )\n  }\n}\n\nexport function sum(arr) {\n  return arr.reduce((prev, curr) => prev + curr, 0)\n}\n\nexport function isFunction(a) {\n  if (typeof a === 'function') {\n    return a\n  }\n}\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj)\n    .join('.')\n    .replace(/\\[/g, '.')\n    .replace(/\\]/g, '')\n    .split('.')\n}\n\nfunction flattenDeep(arr, newArr = []) {\n  if (!Array.isArray(arr)) {\n    newArr.push(arr)\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr)\n    }\n  }\n  return newArr\n}\n","import React from 'react'\n\nexport const defaultState = {}\n\nconst defaultReducer = (old, newState) => newState\n\nexport const useTableState = (\n  initialState = {},\n  overrides,\n  { reducer = defaultReducer, useState: userUseState = React.useState } = {}\n) => {\n  let [state, setState] = userUseState({\n    ...defaultState,\n    ...initialState,\n  })\n\n  const overriddenState = React.useMemo(() => {\n    const newState = {\n      ...state,\n    }\n    if (overrides) {\n      Object.keys(overrides).forEach(key => {\n        newState[key] = overrides[key]\n      })\n    }\n    return newState\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [overrides, state])\n\n  const reducedSetState = React.useCallback(\n    (updater, type) =>\n      setState(old => {\n        const newState = updater(old)\n        return reducer(old, newState, type)\n      }),\n    [reducer, setState]\n  )\n\n  return React.useMemo(() => [overriddenState, reducedSetState], [\n    overriddenState,\n    reducedSetState,\n  ])\n}\n","import PropTypes from 'prop-types'\n//\nimport { flexRender, applyHooks, applyPropHooks, mergeProps } from '../utils'\n\nimport { useTableState } from './useTableState'\n\nconst renderErr =\n  'You must specify a render \"type\". This could be \"Header\", \"Filter\", or any other custom renderers you have set on your column.'\n\nconst propTypes = {\n  // General\n  data: PropTypes.array.isRequired,\n  debug: PropTypes.bool,\n}\n\nexport const useTable = (props, ...plugins) => {\n  // Validate props\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useTable')\n\n  // Destructure props\n  let { data = [], state: userState, debug } = props\n\n  debug = process.env.NODE_ENV === 'production' ? false : debug\n\n  // Always provide a default state\n  const defaultState = useTableState()\n\n  // But use the users state if provided\n  const state = userState || defaultState\n\n  // These are hooks that plugins can use right before render\n  const hooks = {\n    beforeRender: [],\n    columns: [],\n    headers: [],\n    headerGroups: [],\n    rows: [],\n    row: [],\n    renderableRows: [],\n    getTableProps: [],\n    getRowProps: [],\n    getHeaderRowProps: [],\n    getHeaderProps: [],\n    getCellProps: [],\n  }\n\n  // The initial api\n  let api = {\n    ...props,\n    data,\n    state,\n    hooks,\n  }\n\n  if (debug) console.time('hooks')\n  // Loop through plugins to build the api out\n  api = plugins.filter(Boolean).reduce((prev, next) => next(prev), api)\n  if (debug) console.timeEnd('hooks')\n\n  // Run the beforeRender hook\n  if (debug) console.time('hooks.beforeRender')\n  applyHooks(api.hooks.beforeRender, undefined, api)\n  if (debug) console.timeEnd('hooks.beforeRender')\n\n  api.columns.forEach(column => {\n    column.visible =\n      typeof column.show === 'function' ? column.show(api) : !!column.show\n  })\n\n  if (debug) console.time('hooks.columns')\n  api.columns = applyHooks(api.hooks.columns, api.columns, api)\n  if (debug) console.timeEnd('hooks.columns')\n\n  if (debug) console.time('hooks.headers')\n  api.headers = applyHooks(api.hooks.headers, api.headers, api)\n  if (debug) console.timeEnd('hooks.headers')\n  ;[...api.columns, ...api.headers].forEach(column => {\n    // Give columns/headers rendering power\n    column.render = (type, userProps = {}) => {\n      if (!type) {\n        throw new Error(renderErr)\n      }\n      return flexRender(column[type], {\n        ...api,\n        ...column,\n        ...userProps,\n      })\n    }\n\n    // Give columns/headers getHeaderProps\n    column.getHeaderProps = props =>\n      mergeProps(\n        {\n          key: ['header', column.id].join('_'),\n          colSpan: column.columns ? column.columns.length : 1,\n        },\n        applyPropHooks(api.hooks.getHeaderProps, column, api),\n        props\n      )\n  })\n\n  if (debug) console.time('hooks.headerGroups')\n  api.headerGroups = applyHooks(\n    api.hooks.headerGroups,\n    api.headerGroups,\n    api\n  ).filter((headerGroup, i) => {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(header => {\n      const recurse = columns =>\n        columns.filter(column => {\n          if (column.columns) {\n            return recurse(column.columns)\n          }\n          return column.visible\n        }).length\n      if (header.columns) {\n        return recurse(header.columns)\n      }\n      return header.visible\n    })\n\n    // Give headerGroups getRowProps\n    if (headerGroup.headers.length) {\n      headerGroup.getRowProps = (props = {}) =>\n        mergeProps(\n          {\n            key: [`header${i}`].join('_'),\n          },\n          applyPropHooks(api.hooks.getHeaderRowProps, headerGroup, api),\n          props\n        )\n      return true\n    }\n\n    return false\n  })\n  if (debug) console.timeEnd('hooks.headerGroups')\n\n  // Run the rows (this could be a dangerous hook with a ton of data)\n  if (debug) console.time('hooks.rows')\n  api.rows = applyHooks(api.hooks.rows, api.rows, api)\n  if (debug) console.timeEnd('hooks.rows')\n\n  // The prepareRow function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n\n  api.prepareRow = row => {\n    const { path } = row\n    row.getRowProps = props =>\n      mergeProps(\n        { key: ['row', ...path].join('_') },\n        applyPropHooks(api.hooks.getRowProps, row, api),\n        props\n      )\n\n    // need to apply any row specific hooks (useExpanded requires this)\n    applyHooks(api.hooks.row, row, api)\n\n    const visibleColumns = api.columns.filter(column => column.visible)\n\n    // Build the cells for each row\n    row.cells = visibleColumns.map(column => {\n      const cell = {\n        column,\n        row,\n        value: row.values[column.id],\n      }\n\n      cell.getCellProps = props => {\n        const columnPathStr = [path, column.id].join('_')\n        return mergeProps(\n          {\n            key: ['cell', columnPathStr].join('_'),\n          },\n          applyPropHooks(api.hooks.getCellProps, cell, api),\n          props\n        )\n      }\n\n      cell.render = (type, userProps = {}) => {\n        if (!type) {\n          throw new Error(\n            'You must specify a render \"type\". This could be \"Cell\", \"Header\", \"Filter\", \"Aggregated\" or any other custom renderers you have set on your column.'\n          )\n        }\n        return flexRender(column[type], {\n          ...api,\n          ...cell,\n          ...userProps,\n        })\n      }\n\n      return cell\n    })\n  }\n\n  api.getTableProps = userProps =>\n    mergeProps(applyPropHooks(api.hooks.getTableProps, api), userProps)\n\n  api.getRowProps = userProps =>\n    mergeProps(applyPropHooks(api.hooks.getRowProps, undefined, api), userProps)\n\n  return api\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy } from '../utils'\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      Cell: PropTypes.any,\n      Header: PropTypes.any,\n    })\n  ),\n}\n\n// Find the depth of the columns\nfunction findMaxDepth(columns, depth = 0) {\n  return columns.reduce((prev, curr) => {\n    if (curr.columns) {\n      return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n\nfunction decorateColumn(column, parent) {\n  // First check for string accessor\n  let { id, accessor, Header } = column\n\n  if (typeof accessor === 'string') {\n    id = id || accessor\n    const accessorString = accessor\n    accessor = row => getBy(row, accessorString)\n  }\n\n  if (!id && typeof Header === 'string') {\n    id = Header\n  }\n\n  if (!id) {\n    // Accessor, but no column id? This is bad.\n    console.error(column)\n    throw new Error('A column ID (or string accessor) is required!')\n  }\n\n  column = {\n    Header: '',\n    Cell: cell => cell.value,\n    show: true,\n    ...column,\n    id,\n    accessor,\n    parent,\n  }\n\n  return column\n}\n\n// Build the visible columns, headers and flat column list\nfunction decorateColumnTree(columns, parent, depth = 0) {\n  return columns.map(column => {\n    column = decorateColumn(column, parent)\n    if (column.columns) {\n      column.columns = decorateColumnTree(column.columns, column, depth + 1)\n    }\n    return column\n  })\n}\n\n// Build the header groups from the bottom up\nfunction makeHeaderGroups(columns, maxDepth) {\n  const headerGroups = []\n\n  const removeChildColumns = column => {\n    delete column.columns\n    if (column.parent) {\n      removeChildColumns(column.parent)\n    }\n  }\n  columns.forEach(removeChildColumns)\n\n  const buildGroup = (columns, depth = 0) => {\n    const headerGroup = {\n      headers: [],\n    }\n\n    const parentColumns = []\n\n    const hasParents = columns.some(col => col.parent)\n\n    columns.forEach(column => {\n      const isFirst = !parentColumns.length\n      let latestParentColumn = [...parentColumns].reverse()[0]\n\n      // If the column has a parent, add it if necessary\n      if (column.parent) {\n        if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n          parentColumns.push({\n            ...column.parent,\n            originalID: column.parent.id,\n            id: [column.parent.id, parentColumns.length].join('_'),\n          })\n        }\n      } else if (hasParents) {\n        // If other columns have parents, add a place holder if necessary\n        const placeholderColumn = decorateColumn({\n          originalID: [column.id, 'placeholder', maxDepth - depth].join('_'),\n          id: [\n            column.id,\n            'placeholder',\n            maxDepth - depth,\n            parentColumns.length,\n          ].join('_'),\n        })\n        if (\n          isFirst ||\n          latestParentColumn.originalID !== placeholderColumn.originalID\n        ) {\n          parentColumns.push(placeholderColumn)\n        }\n      }\n\n      // Establish the new columns[] relationship on the parent\n      if (column.parent || hasParents) {\n        latestParentColumn = [...parentColumns].reverse()[0]\n        latestParentColumn.columns = latestParentColumn.columns || []\n        if (!latestParentColumn.columns.includes(column)) {\n          latestParentColumn.columns.push(column)\n        }\n      }\n\n      headerGroup.headers.push(column)\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (parentColumns.length) {\n      buildGroup(parentColumns)\n    }\n  }\n\n  buildGroup(columns)\n\n  return headerGroups.reverse()\n}\n\nexport const useColumns = props => {\n  const {\n    debug,\n    columns: userColumns,\n    state: [{ groupBy }],\n  } = props\n\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useColumns')\n\n  const { columns, headerGroups, headers } = useMemo(() => {\n    if (debug) console.info('getColumns')\n\n    // Decorate All the columns\n    let columnTree = decorateColumnTree(userColumns)\n\n    // Get the flat list of all columns\n    let columns = flattenBy(columnTree, 'columns')\n\n    columns = [\n      ...groupBy.map(g => columns.find(col => col.id === g)),\n      ...columns.filter(col => !groupBy.includes(col.id)),\n    ]\n\n    // Get headerGroups\n    const headerGroups = makeHeaderGroups(columns, findMaxDepth(columnTree))\n    const headers = flattenBy(headerGroups, 'headers')\n\n    return {\n      columns,\n      headerGroups,\n      headers,\n    }\n  }, [debug, groupBy, userColumns])\n\n  return {\n    ...props,\n    columns,\n    headerGroups,\n    headers,\n  }\n\n  function flattenBy(columns, childKey) {\n    const flatColumns = []\n\n    const recurse = columns => {\n      columns.forEach(d => {\n        if (!d[childKey]) {\n          flatColumns.push(d)\n        } else {\n          recurse(d[childKey])\n        }\n      })\n    }\n\n    recurse(columns)\n\n    return flatColumns\n  }\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst propTypes = {\n  subRowsKey: PropTypes.string,\n}\n\nexport const useRows = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useRows')\n\n  const { debug, columns, subRowsKey = 'subRows', data } = props\n\n  const accessedRows = useMemo(() => {\n    if (debug) console.info('getAccessedRows')\n\n    // Access the row's data\n    const accessRow = (originalRow, i, depth = 0) => {\n      // Keep the original reference around\n      const original = originalRow\n\n      // Process any subRows\n      const subRows = originalRow[subRowsKey]\n        ? originalRow[subRowsKey].map((d, i) => accessRow(d, i, depth + 1))\n        : undefined\n\n      const row = {\n        original,\n        index: i,\n        path: [i], // used to create a key for each row even if not nested\n        subRows,\n        depth,\n        cells: [{}], // This is a dummy cell\n      }\n\n      // Override common array functions (and the dummy cell's getCellProps function)\n      // to show an error if it is accessed without calling prepareRow\n      const unpreparedAccessWarning = () => {\n        throw new Error(\n          'React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.'\n        )\n      }\n      row.cells.map = unpreparedAccessWarning\n      row.cells.filter = unpreparedAccessWarning\n      row.cells.forEach = unpreparedAccessWarning\n      row.cells[0].getCellProps = unpreparedAccessWarning\n\n      // Create the cells and values\n      row.values = {}\n      columns.forEach(column => {\n        row.values[column.id] = column.accessor\n          ? column.accessor(originalRow, i, { subRows, depth, data })\n          : undefined\n      })\n\n      return row\n    }\n\n    // Use the resolved data\n    return data.map((d, i) => accessRow(d, i))\n  }, [debug, data, subRowsKey, columns])\n\n  return {\n    ...props,\n    rows: accessedRows,\n  }\n}\n","const actions = {}\n\nexport { actions }\n\nexport const addActions = acts => {\n  Object.keys(acts).forEach(key => {\n    actions[key] = acts[key]\n  })\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy, getFirstDefined, setBy } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.expanded = {}\n\naddActions({\n  toggleExpanded: '__toggleExpanded__',\n  useExpanded: '__useExpanded__',\n})\n\nconst propTypes = {\n  manualExpandedKey: PropTypes.string,\n  paginateSubRows: PropTypes.bool,\n}\n\nexport const useExpanded = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useExpanded')\n\n  const {\n    debug,\n    rows,\n    manualExpandedKey = 'expanded',\n    hooks,\n    state: [{ expanded }, setState],\n    paginateSubRows = true,\n  } = props\n\n  const toggleExpandedByPath = (path, set) => {\n    return setState(old => {\n      const { expanded } = old\n      const existing = getBy(expanded, path)\n      set = getFirstDefined(set, !existing)\n      return {\n        ...old,\n        expanded: setBy(expanded, path, set),\n      }\n    }, actions.toggleExpanded)\n  }\n\n  hooks.row.push(row => {\n    const { path } = row\n    row.toggleExpanded = set => toggleExpandedByPath(path, set)\n    return row\n  })\n\n  const expandedRows = useMemo(() => {\n    if (debug) console.info('getExpandedRows')\n\n    const expandedRows = []\n\n    // Here we do some mutation, but it's the last stage in the\n    // immutable process so this is safe\n    const handleRow = (row, depth = 0, parentPath = []) => {\n      // Compute some final state for the row\n      const path = [...parentPath, row.index]\n\n      row.path = path\n      row.depth = depth\n\n      row.isExpanded =\n        (row.original && row.original[manualExpandedKey]) ||\n        getBy(expanded, path)\n\n      if (paginateSubRows || (!paginateSubRows && row.depth === 0)) {\n        expandedRows.push(row)\n      }\n\n      if (row.isExpanded && row.subRows && row.subRows.length) {\n        row.subRows.forEach((row, i) => handleRow(row, depth + 1, path))\n      }\n\n      return row\n    }\n\n    rows.forEach(row => handleRow(row))\n\n    return expandedRows\n  }, [debug, rows, manualExpandedKey, expanded, paginateSubRows])\n\n  const expandedDepth = findExpandedDepth(expanded)\n\n  return {\n    ...props,\n    toggleExpandedByPath,\n    expandedDepth,\n    rows: expandedRows,\n  }\n}\n\nfunction findExpandedDepth(obj, depth = 1) {\n  return Object.values(obj).reduce((prev, curr) => {\n    if (typeof curr === 'object') {\n      return Math.max(prev, findExpandedDepth(curr, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n","export const text = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue !== undefined\n      ? String(rowValue)\n          .toLowerCase()\n          .includes(String(filterValue).toLowerCase())\n      : true\n  })\n}\n\nexport const exactText = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue !== undefined\n      ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase()\n      : true\n  })\n}\n\nexport const exactTextCase = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue !== undefined\n      ? String(rowValue) === String(filterValue)\n      : true\n  })\n}\n\nexport const includes = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return filterValue.includes(rowValue)\n  })\n}\n\nexport const includesAll = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return filterValue.every(val => rowValue.includes(val))\n  })\n}\n\nexport const exact = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue === filterValue\n  })\n}\n\nexport const between = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue >= filterValue[0] && rowValue <= filterValue[1]\n  })\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getFirstDefined, isFunction } from '../utils'\nimport * as filterTypes from '../filterTypes'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.filters = {}\naddActions({\n  setFilter: '__setFilter__',\n  setAllFilters: '__setAllFilters__',\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      filterFn: PropTypes.func,\n      filterAll: PropTypes.bool,\n      canFilter: PropTypes.bool,\n      Filter: PropTypes.any,\n    })\n  ),\n\n  filterFn: PropTypes.func,\n  manualFilters: PropTypes.bool,\n}\n\nexport const useFilters = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFilters')\n\n  const {\n    debug,\n    rows,\n    columns,\n    filterTypes: userFilterTypes = {},\n    defaultFilter = filterTypes.text,\n    manualFilters,\n    disableFilters,\n    hooks,\n    state: [{ filters }, setState],\n  } = props\n\n  const setFilter = (id, val) => {\n    return setState(old => {\n      if (typeof val === 'undefined') {\n        const { [id]: prev, ...rest } = filters\n        return {\n          ...old,\n          filters: {\n            ...rest,\n          },\n        }\n      }\n\n      return {\n        ...old,\n        filters: {\n          ...filters,\n          [id]: val,\n        },\n      }\n    }, actions.setFilter)\n  }\n\n  const setAllFilters = filters => {\n    return setState(old => {\n      return {\n        ...old,\n        filters,\n      }\n    }, actions.setAllFilters)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      const { id, accessor, canFilter } = column\n\n      // Determine if a column is filterable\n      column.canFilter = accessor\n        ? getFirstDefined(\n            canFilter,\n            disableFilters === true ? false : undefined,\n            true\n          )\n        : false\n\n      // Provide the column a way of updating the filter value\n      column.setFilter = val => setFilter(column.id, val)\n\n      // Provide the current filter value to the column for\n      // convenience\n      column.filterValue = filters[id]\n    })\n\n    return columns\n  })\n\n  const filteredRows = useMemo(() => {\n    if (manualFilters || !Object.keys(filters).length) {\n      return rows\n    }\n\n    if (debug) console.info('getFilteredRows')\n\n    // Filters top level and nested rows\n    const filterRows = rows => {\n      let filteredRows = rows\n\n      filteredRows = Object.entries(filters).reduce(\n        (filteredSoFar, [columnID, filterValue]) => {\n          // Find the filters column\n          const column = columns.find(d => d.id === columnID)\n\n          // Don't filter hidden columns or columns that have had their filters disabled\n          if (!column || column.filterable === false) {\n            return filteredSoFar\n          }\n\n          // Look up filter functions in this order:\n          // column function\n          // column string lookup on user filters\n          // column string lookup on built-in filters\n          // default function\n          // default string lookup on user filters\n          // default string lookup on built-in filters\n          const filterMethod =\n            isFunction(column.filter) ||\n            userFilterTypes[column.filter] ||\n            filterTypes[column.filter] ||\n            isFunction(defaultFilter) ||\n            userFilterTypes[defaultFilter] ||\n            filterTypes[defaultFilter]\n\n          if (!filterMethod) {\n            console.warn(\n              `Could not find a valid 'column.filter' for column with the ID: ${\n                column.id\n              }.`\n            )\n            return filteredSoFar\n          }\n\n          // Pass the rows, id, filterValue and column to the filterMethod\n          // to get the filtered rows back\n          return filterMethod(filteredSoFar, columnID, filterValue, column)\n        },\n        rows\n      )\n\n      // Apply the filter to any subRows\n      filteredRows = filteredRows.map(row => {\n        if (!row.subRows) {\n          return row\n        }\n        return {\n          ...row,\n          subRows: filterRows(row.subRows),\n        }\n      })\n\n      // then filter any rows without subcolumns because it would be strange to show\n      filteredRows = filteredRows.filter(row => {\n        if (!row.subRows) {\n          return true\n        }\n        return row.subRows.length > 0\n      })\n\n      return filteredRows\n    }\n\n    return filterRows(rows)\n  }, [\n    manualFilters,\n    filters,\n    debug,\n    rows,\n    columns,\n    userFilterTypes,\n    defaultFilter,\n  ])\n\n  return {\n    ...props,\n    setFilter,\n    setAllFilters,\n    rows: filteredRows,\n  }\n}\n","export function sum(values, rows) {\n  return values.reduce((sum, next) => sum + next, 0)\n}\n\nexport function average(values, rows) {\n  return Math.round((sum(values, rows) / values.length) * 100) / 100\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport * as aggregations from '../aggregations'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport {\n  mergeProps,\n  applyPropHooks,\n  defaultGroupByFn,\n  getFirstDefined,\n} from '../utils'\n\ndefaultState.groupBy = []\n\naddActions({\n  toggleGroupBy: '__toggleGroupBy__',\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      aggregate: PropTypes.func,\n      canGroupBy: PropTypes.bool,\n      Aggregated: PropTypes.any,\n    })\n  ),\n  groupByFn: PropTypes.func,\n  manualGrouping: PropTypes.bool,\n  aggregations: PropTypes.object,\n}\n\nexport const useGroupBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useGroupBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    disableGrouping,\n    aggregations: userAggregations = {},\n    hooks,\n    state: [{ groupBy }, setState],\n  } = props\n\n  columns.forEach(column => {\n    const { id, accessor, canGroupBy } = column\n    column.grouped = groupBy.includes(id)\n\n    column.canGroupBy = accessor\n      ? getFirstDefined(\n          canGroupBy,\n          disableGrouping === true ? false : undefined,\n          true\n        )\n      : false\n\n    column.Aggregated = column.Aggregated || column.Cell\n  })\n\n  const toggleGroupBy = (id, toggle) => {\n    return setState(old => {\n      const resolvedToggle =\n        typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id)\n      if (resolvedToggle) {\n        return {\n          ...old,\n          groupBy: [...groupBy, id],\n        }\n      }\n      return {\n        ...old,\n        groupBy: groupBy.filter(d => d !== id),\n      }\n    }, actions.toggleGroupBy)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canGroupBy) {\n        column.toggleGroupBy = () => toggleGroupBy(column.id)\n      }\n    })\n    return columns\n  })\n\n  hooks.getGroupByToggleProps = []\n\n  const addGroupByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canGroupBy } = column\n      column.getGroupByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canGroupBy\n              ? e => {\n                  e.persist()\n                  column.toggleGroupBy()\n                }\n              : undefined,\n            style: {\n              cursor: canGroupBy ? 'pointer' : undefined,\n            },\n            title: 'Toggle GroupBy',\n          },\n          applyPropHooks(api.hooks.getGroupByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addGroupByToggleProps)\n  hooks.headers.push(addGroupByToggleProps)\n\n  const groupedRows = useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return rows\n    }\n    if (debug) console.info('getGroupedRows')\n    // Find the columns that can or are aggregating\n\n    // Uses each column to aggregate rows into a single value\n    const aggregateRowsToValues = rows => {\n      const values = {}\n      columns.forEach(column => {\n        const columnValues = rows.map(d => d.values[column.id])\n        let aggregate =\n          userAggregations[column.aggregate] ||\n          aggregations[column.aggregate] ||\n          column.aggregate\n        if (typeof aggregate === 'function') {\n          values[column.id] = aggregate(columnValues, rows)\n        } else if (aggregate) {\n          throw new Error(\n            `Invalid aggregate \"${aggregate}\" passed to column with ID: \"${\n              column.id\n            }\"`\n          )\n        } else {\n          values[column.id] = columnValues[0]\n        }\n      })\n      return values\n    }\n\n    // Recursively group the data\n    const groupRecursively = (rows, groupBy, depth = 0) => {\n      // This is the last level, just return the rows\n      if (depth >= groupBy.length) {\n        return rows\n      }\n\n      // Group the rows together for this level\n      let groupedRows = Object.entries(groupByFn(rows, groupBy[depth])).map(\n        ([groupByVal, subRows], index) => {\n          // Recurse to sub rows before aggregation\n          subRows = groupRecursively(subRows, groupBy, depth + 1)\n\n          const values = aggregateRowsToValues(subRows)\n\n          const row = {\n            groupByID: groupBy[depth],\n            groupByVal,\n            values,\n            subRows,\n            depth,\n            index,\n          }\n          return row\n        }\n      )\n\n      return groupedRows\n    }\n\n    // Assign the new data\n    return groupRecursively(rows, groupBy)\n  }, [\n    manualGroupBy,\n    groupBy,\n    debug,\n    rows,\n    columns,\n    userAggregations,\n    groupByFn,\n  ])\n\n  return {\n    ...props,\n    rows: groupedRows,\n  }\n}\n","const reSplitAlphaNumeric = /([0-9]+)/gm\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nexport const alphaNumeric = (a, b) => {\n  // Force to strings (or \"\" for unsupported types)\n  a = toString(a)\n  b = toString(b)\n\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  a = a.split(reSplitAlphaNumeric).filter(Boolean)\n  b = b.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    let aa = a.shift()\n    let bb = b.shift()\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\nexport function datetime(a, b) {\n  a = a.getTime()\n  b = b.getTime()\n  return numeric(a, b)\n}\n\nexport function numeric(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\n// Utils\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport * as sortTypes from '../sortTypes'\nimport {\n  mergeProps,\n  applyPropHooks,\n  getFirstDefined,\n  defaultOrderByFn,\n  isFunction,\n} from '../utils'\n\ndefaultState.sortBy = []\n\naddActions({\n  sortByChange: '__sortByChange__',\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      sortBy: PropTypes.func,\n      defaultSortDesc: PropTypes.bool,\n    })\n  ),\n  orderByFn: PropTypes.func,\n  sortTypes: PropTypes.object,\n  defaultSortType: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  manualSorting: PropTypes.bool,\n  disableSorting: PropTypes.bool,\n  defaultSortDesc: PropTypes.bool,\n  disableMultiSort: PropTypes.bool,\n  disableSortRemove: PropTypes.bool,\n}\n\nexport const useSortBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useSortBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    orderByFn = defaultOrderByFn,\n    defaultSort = 'alphanumeric',\n    sortTypes: userSortTypes = {},\n    manualSorting,\n    disableSorting,\n    defaultSortDesc,\n    disableSortRemove,\n    disableMultiSort,\n    hooks,\n    state: [{ sortBy }, setState],\n  } = props\n\n  columns.forEach(column => {\n    const { accessor, canSortBy } = column\n    column.canSortBy = accessor\n      ? getFirstDefined(\n          canSortBy,\n          disableSorting === true ? false : undefined,\n          true\n        )\n      : false\n  })\n\n  // Updates sorting based on a columnID, desc flag and multi flag\n  const toggleSortByID = (columnID, desc, multi) => {\n    return setState(old => {\n      const { sortBy } = old\n\n      // Find the column for this columnID\n      const column = columns.find(d => d.id === columnID)\n      const resolvedDefaultSortDesc = getFirstDefined(\n        column.defaultSortDesc,\n        defaultSortDesc\n      )\n\n      // Find any existing sortBy for this column\n      const existingSortBy = sortBy.find(d => d.id === columnID)\n      const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n      let newSortBy = []\n\n      // What should we do with this filter?\n      let action\n\n      if (disableMultiSort || !multi) {\n        if (sortBy.length <= 1 && existingSortBy) {\n          if (\n            (existingSortBy.desc && !resolvedDefaultSortDesc) ||\n            (!existingSortBy.desc && resolvedDefaultSortDesc)\n          ) {\n            action = disableSortRemove ? 'toggle' : 'remove'\n          } else {\n            action = 'toggle'\n          }\n        } else {\n          action = 'replace'\n        }\n      } else {\n        if (!existingSortBy) {\n          action = 'add'\n        } else {\n          if (hasDescDefined) {\n            action = 'set'\n          } else {\n            action = 'toggle'\n          }\n        }\n      }\n\n      if (action === 'replace') {\n        newSortBy = [\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc,\n          },\n        ]\n      } else if (action === 'add') {\n        newSortBy = [\n          ...sortBy,\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc,\n          },\n        ]\n      } else if (action === 'set') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc,\n            }\n          }\n          return d\n        })\n      } else if (action === 'toggle') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc: !existingSortBy.desc,\n            }\n          }\n          return d\n        })\n      } else if (action === 'remove') {\n        newSortBy = []\n      }\n\n      return {\n        ...old,\n        sortBy: newSortBy,\n      }\n    }, actions.sortByChange)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canSortBy) {\n        column.toggleSortBy = (desc, multi) =>\n          toggleSortByID(column.id, desc, multi)\n      }\n    })\n    return columns\n  })\n\n  hooks.getSortByToggleProps = []\n\n  const addSortByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canSortBy } = column\n      column.getSortByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canSortBy\n              ? e => {\n                  e.persist()\n                  column.toggleSortBy(\n                    undefined,\n                    !api.disableMultiSort && e.shiftKey\n                  )\n                }\n              : undefined,\n            style: {\n              cursor: canSortBy ? 'pointer' : undefined,\n            },\n            title: 'Toggle SortBy',\n          },\n          applyPropHooks(api.hooks.getSortByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addSortByToggleProps)\n  hooks.headers.push(addSortByToggleProps)\n\n  // Mutate columns to reflect sorting state\n  columns.forEach(column => {\n    const { id } = column\n    column.sorted = sortBy.find(d => d.id === id)\n    column.sortedIndex = sortBy.findIndex(d => d.id === id)\n    column.sortedDesc = column.sorted ? column.sorted.desc : undefined\n  })\n\n  const sortedRows = useMemo(() => {\n    if (manualSorting || !sortBy.length) {\n      return rows\n    }\n    if (debug) console.info('getSortedRows')\n\n    const sortTypesByColumnID = {}\n\n    columns.forEach(col => {\n      sortTypesByColumnID[col.id] = col.sortBy\n    })\n\n    const sortData = rows => {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = orderByFn(\n        rows,\n        sortBy.map(sort => {\n          // Support custom sorting methods for each column\n          const columnSort = sortTypesByColumnID[sort.id]\n\n          // Look up sortBy functions in this order:\n          // column function\n          // column string lookup on user sortType\n          // column string lookup on built-in sortType\n          // default function\n          // default string lookup on user sortType\n          // default string lookup on built-in sortType\n          const sortMethod =\n            isFunction(columnSort) ||\n            userSortTypes[columnSort] ||\n            sortTypes[columnSort] ||\n            isFunction(defaultSort) ||\n            userSortTypes[defaultSort] ||\n            sortTypes[defaultSort]\n\n          // Return the correct sortFn\n          return (a, b) =>\n            sortMethod(a.values[sort.id], b.values[sort.id], sort.desc)\n        }),\n        // Map the directions\n        sortBy.map(d => !d.desc)\n      )\n\n      // If there are sub-rows, sort them\n      sortedData.forEach(row => {\n        if (!row.subRows) {\n          return\n        }\n        row.subRows = sortData(row.subRows)\n      })\n\n      return sortedData\n    }\n\n    return sortData(rows)\n  }, [\n    manualSorting,\n    sortBy,\n    debug,\n    columns,\n    rows,\n    orderByFn,\n    userSortTypes,\n    defaultSort,\n  ])\n\n  return {\n    ...props,\n    rows: sortedRows,\n  }\n}\n","import { useMemo, useLayoutEffect } from 'react'\nimport PropTypes from 'prop-types'\n\n//\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.pageSize = 10\ndefaultState.pageIndex = 0\n\naddActions({\n  pageChange: '__pageChange__',\n  pageSizeChange: '__pageSizeChange__',\n})\n\nconst propTypes = {\n  // General\n  manualPagination: PropTypes.bool,\n}\n\nexport const usePagination = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'usePagination')\n\n  const {\n    rows,\n    manualPagination,\n    disablePageResetOnDataChange,\n    debug,\n    state: [\n      {\n        pageSize,\n        pageIndex,\n        pageCount: userPageCount,\n        filters,\n        groupBy,\n        sortBy,\n      },\n      setState,\n    ],\n  } = props\n\n  const pageOptions = useMemo(\n    () => [...new Array(userPageCount)].map((d, i) => i),\n    [userPageCount]\n  )\n\n  const rowDep = disablePageResetOnDataChange ? null : rows\n\n  useLayoutEffect(() => {\n    setState(\n      old => ({\n        ...old,\n        pageIndex: 0,\n      }),\n      actions.pageChange\n    )\n  }, [setState, rowDep, filters, groupBy, sortBy])\n\n  const { pages, pageCount } = useMemo(() => {\n    if (manualPagination) {\n      return {\n        pages: [rows],\n        pageCount: userPageCount,\n      }\n    }\n    if (debug) console.info('getPages')\n\n    // Create a new pages with the first page ready to go.\n    const pages = rows.length ? [] : [[]]\n\n    // Start the pageIndex and currentPage cursors\n    let cursor = 0\n    while (cursor < rows.length) {\n      const end = cursor + pageSize\n      pages.push(rows.slice(cursor, end))\n      cursor = end\n    }\n\n    const pageCount = pages.length\n\n    return {\n      pages,\n      pageCount,\n      pageOptions,\n    }\n  }, [manualPagination, debug, rows, pageOptions, userPageCount, pageSize])\n\n  const page = manualPagination ? rows : pages[pageIndex] || []\n  const canPreviousPage = pageIndex > 0\n  const canNextPage = pageIndex < pageCount - 1\n\n  const gotoPage = pageIndex => {\n    if (debug) console.info('gotoPage')\n    return setState(old => {\n      if (pageIndex < 0 || pageIndex > pageCount - 1) {\n        return old\n      }\n      return {\n        ...old,\n        pageIndex,\n      }\n    }, actions.pageChange)\n  }\n\n  const previousPage = () => {\n    return gotoPage(pageIndex - 1)\n  }\n\n  const nextPage = () => {\n    return gotoPage(pageIndex + 1)\n  }\n\n  const setPageSize = pageSize => {\n    setState(old => {\n      const topRowIndex = old.pageSize * old.pageIndex\n      const pageIndex = Math.floor(topRowIndex / pageSize)\n      return {\n        ...old,\n        pageIndex,\n        pageSize,\n      }\n    }, actions.pageSizeChange)\n  }\n\n  return {\n    ...props,\n    pages,\n    pageOptions,\n    pageCount,\n    page,\n    canPreviousPage,\n    canNextPage,\n    gotoPage,\n    previousPage,\n    nextPage,\n    setPageSize,\n    pageIndex,\n    pageSize,\n  }\n}\n","import PropTypes from 'prop-types'\n\nimport { getFirstDefined, sum } from '../utils'\n\nexport const actions = {}\n\nconst propTypes = {\n  defaultFlex: PropTypes.number,\n}\n\nexport const useFlexLayout = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFlexLayout')\n\n  const {\n    defaultFlex = 1,\n    hooks: {\n      columns: columnsHooks,\n      getRowProps,\n      getHeaderRowProps,\n      getHeaderProps,\n      getCellProps,\n    },\n  } = props\n\n  columnsHooks.push((columns, api) => {\n    const visibleColumns = columns.filter(column => column.visible)\n    const columnMeasurements = {}\n\n    let sumWidth = 0\n    visibleColumns.forEach(column => {\n      const { width, minWidth } = getSizesForColumn(\n        column,\n        defaultFlex,\n        undefined,\n        undefined,\n        api\n      )\n      if (width) {\n        sumWidth += width\n      } else if (minWidth) {\n        sumWidth += minWidth\n      } else {\n        sumWidth += defaultFlex\n      }\n    })\n\n    const rowStyles = {\n      style: {\n        display: 'flex',\n        minWidth: `${sumWidth}px`,\n      },\n    }\n\n    api.rowStyles = rowStyles\n\n    getRowProps.push(() => rowStyles)\n    getHeaderRowProps.push(() => rowStyles)\n\n    getHeaderProps.push(column => ({\n      style: {\n        boxSizing: 'border-box',\n        ...getStylesForColumn(column, columnMeasurements, defaultFlex, api),\n      },\n    }))\n\n    getCellProps.push(cell => {\n      return {\n        style: {\n          ...getStylesForColumn(\n            cell.column,\n            columnMeasurements,\n            defaultFlex,\n            undefined,\n            api\n          ),\n        },\n      }\n    })\n\n    return columns\n  })\n\n  return props\n}\n\n// Utils\n\nfunction getStylesForColumn(column, columnMeasurements, defaultFlex, api) {\n  const { flex, width, maxWidth } = getSizesForColumn(\n    column,\n    columnMeasurements,\n    defaultFlex,\n    api\n  )\n\n  return {\n    flex: `${flex} 0 auto`,\n    width: `${width}px`,\n    maxWidth: `${maxWidth}px`,\n  }\n}\n\nfunction getSizesForColumn(\n  { columns, id, width, minWidth, maxWidth },\n  columnMeasurements,\n  defaultFlex,\n  api\n) {\n  if (columns) {\n    columns = columns\n      .filter(col => col.show || col.visible)\n      .map(column =>\n        getSizesForColumn(column, columnMeasurements, defaultFlex, api)\n      )\n      .filter(Boolean)\n\n    if (!columns.length) {\n      return false\n    }\n\n    const flex = sum(columns.map(col => col.flex))\n    const width = sum(columns.map(col => col.width))\n    const maxWidth = sum(columns.map(col => col.maxWidth))\n\n    return {\n      flex,\n      width,\n      maxWidth,\n    }\n  }\n\n  return {\n    flex: width ? 0 : defaultFlex,\n    width:\n      width === 'auto'\n        ? columnMeasurements[id] || defaultFlex\n        : getFirstDefined(width, minWidth, defaultFlex),\n    maxWidth,\n  }\n}\n","import React from 'react'\n\n// Token pagination behaves a bit differently from\n// index based pagination. This hook aids in that process.\n\nexport const useTokenPagination = () => {\n  const [pageToken, setPageToken] = React.useState()\n  const [nextPageToken, setNextPageToken] = React.useState()\n  const [previousPageTokens, setPreviousPageTokens] = React.useState([])\n  const [pageIndex, setPageIndex] = React.useState(0)\n\n  // Since we're using pagination tokens intead of index, we need\n  // to be a bit clever with page-like navigation here.\n  const nextPage = () => {\n    setPageIndex(old => old + 1)\n    setPreviousPageTokens(old => [...old, pageToken])\n    setPageToken(nextPageToken)\n  }\n\n  const previousPage = () => {\n    setPageIndex(old => old - 1)\n    setPreviousPageTokens(old =>\n      [...old]\n        .reverse()\n        .slice(1)\n        .reverse()\n    )\n    setPageToken(previousPageTokens[previousPageTokens.length - 1])\n  }\n\n  const resetPagination = () => {\n    setPageToken(undefined)\n    setPageIndex(0)\n    setNextPageToken(undefined)\n    setPreviousPageTokens([])\n  }\n\n  const canPreviousPage = previousPageTokens.length\n  const canNextPage = nextPageToken\n\n  return {\n    setNextPageToken,\n    pageToken,\n    pageIndex,\n    previousPage,\n    nextPage,\n    canPreviousPage,\n    canNextPage,\n    resetPagination,\n  }\n}\n"],"names":["getBy","obj","path","def","val","pathObj","makePathArray","reduce","cursor","pathPart","e","defaultOrderByFn","arr","funcs","dirs","_toConsumableArray","sort","rowA","rowB","i","length","sortFn","desc","sortInt","index","getFirstDefined","arguments","defaultGroupByFn","rows","grouper","prev","row","resKey","values","Array","isArray","push","setBy","value","recurse","depth","key","target","_typeof","flexRender","Comp","props","Object","getPrototypeOf","isReactComponent","React","mergeProps","groups","forEach","style","className","rest","filter","Boolean","join","applyHooks","hooks","initial","args","next","applyPropHooks","sum","curr","isFunction","a","flattenDeep","replace","split","newArr","defaultState","defaultReducer","old","newState","useTableState","initialState","overrides","reducer","useState","state","setState","overriddenState","useMemo","keys","reducedSetState","useCallback","updater","type","renderErr","propTypes","data","PropTypes","array","isRequired","debug","bool","useTable","checkPropTypes","userState","process","env","NODE_ENV","api","beforeRender","columns","headers","headerGroups","renderableRows","getTableProps","getRowProps","getHeaderRowProps","getHeaderProps","getCellProps","console","time","plugins","timeEnd","undefined","column","visible","show","render","userProps","Error","id","colSpan","headerGroup","header","prepareRow","visibleColumns","cells","map","cell","columnPathStr","arrayOf","shape","Cell","any","Header","findMaxDepth","Math","max","decorateColumn","parent","accessor","accessorString","error","decorateColumnTree","makeHeaderGroups","maxDepth","removeChildColumns","buildGroup","parentColumns","hasParents","some","col","isFirst","latestParentColumn","reverse","originalID","placeholderColumn","includes","useColumns","userColumns","groupBy","info","columnTree","flattenBy","g","find","childKey","flatColumns","d","subRowsKey","string","useRows","accessRow","originalRow","original","subRows","unpreparedAccessWarning","actions","addActions","acts","expanded","toggleExpanded","useExpanded","manualExpandedKey","paginateSubRows","toggleExpandedByPath","set","existing","expandedRows","handleRow","parentPath","isExpanded","expandedDepth","findExpandedDepth","text","filterValue","rowValue","String","toLowerCase","exactText","exactTextCase","includesAll","every","exact","between","filters","setFilter","setAllFilters","filterFn","func","filterAll","canFilter","Filter","manualFilters","useFilters","filterTypes","userFilterTypes","defaultFilter","disableFilters","filteredRows","filterRows","entries","filteredSoFar","columnID","filterable","filterMethod","warn","average","round","toggleGroupBy","aggregate","canGroupBy","Aggregated","groupByFn","manualGrouping","aggregations","object","useGroupBy","manualGroupBy","disableGrouping","userAggregations","grouped","toggle","getGroupByToggleProps","addGroupByToggleProps","onClick","persist","title","groupRecursively","groupByVal","columnValues","groupByID","reSplitAlphaNumeric","alphaNumeric","b","toString","aa","shift","bb","an","parseInt","bn","combo","isNaN","datetime","numeric","getTime","Infinity","sortBy","sortByChange","defaultSortDesc","orderByFn","sortTypes","defaultSortType","oneOfType","manualSorting","disableSorting","disableMultiSort","disableSortRemove","useSortBy","defaultSort","userSortTypes","canSortBy","toggleSortBy","multi","action","resolvedDefaultSortDesc","existingSortBy","hasDescDefined","newSortBy","getSortByToggleProps","addSortByToggleProps","shiftKey","sorted","sortedIndex","findIndex","sortedDesc","sortTypesByColumnID","sortData","sortedData","columnSort","sortMethod","pageSize","pageIndex","pageChange","pageSizeChange","manualPagination","usePagination","disablePageResetOnDataChange","userPageCount","pageCount","pageOptions","rowDep","useLayoutEffect","pages","end","slice","page","gotoPage","canPreviousPage","canNextPage","previousPage","nextPage","setPageSize","topRowIndex","floor","defaultFlex","number","useFlexLayout","columnsHooks","columnMeasurements","sumWidth","getSizesForColumn","width","minWidth","rowStyles","display","boxSizing","getStylesForColumn","flex","maxWidth","useTokenPagination","pageToken","setPageToken","nextPageToken","setNextPageToken","previousPageTokens","setPreviousPageTokens","setPageIndex","resetPagination"],"mappings":"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"}